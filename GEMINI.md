# Repository Guidelines

This repo is a reusable Golang clean architecture template. The `architecture.png` diagram (mirrored in `architecture.excalidraw`) plus `README.md` explain the request flow: external callers hit delivery adapters, which translate into use cases, which enforce business rules through entities and repositories, and optionally reach external services through gateways. Everything is wired from the entrypoints under `cmd/`, so every change should be traceable from an executable back down to the entity and persistence layers.

## 1. System & Execution Overview
- **Entrypoints**: `cmd/web` boots the HTTP server and swagger UI, `cmd/worker` runs async workers/schedulers, and `cmd/migrate` applies SQL migrations located in `db/migrations`.
- **Runtime workflow**: Bring up infra with `make docker-compose`, run `make migrate`, then `make run` (or `make run-worker`) from another terminal. Swagger lives at `http://localhost:3000/swagger`.
- **Template setup**: Run `make check-tools` to verify required CLIs, and `make rename-go-mod` once when cloning the template so the Go module path matches your org.
- **Observability**: `signoz/` + `docker-compose.yml` provide tracing/logging stacks used during `make docker-compose`.

## 2. Repository Map
- `cmd/`: Binary entrypoints with wiring, flags, middlewares, and dependency injection per executable.
- `internal/`: Clean architecture core.
  - `delivery`: HTTP / worker handlers, validation, presenter logic.
  - `usecase`: Application services orchestrating repositories and gateways. Unlike layer delivery and repository, layer usecase we split based on domain.
  - `entity` & `model`: Domain structs (entity) versus transport/view models (model).
  - `repository`: Interfaces + implementations over databases or caches.
  - `gateway`: Clients for outbound HTTP/gRPC/queue calls.
  - `config`: Runtime configuration loaders.
  - `mock`: Autogenerated test doubles for usecases/repositories/gateways—do not hand-edit; regenerate instead.
- `pkg/`: Shared utilities (logging, errors, middleware primitives) that remain framework-agnostic.
- `db/migrations`: Timestamped SQL files consumed by `cmd/migrate`.
- `api/`: Generated Swagger specs and client/server stubs. Never edit by hand.
- `signoz/`: Docker-compose fragments and dashboards for observability lab environments.
- Root docs & helpers: `README.md`, `run_app.md` (step-by-step runbook), `README_my_note.md` (author notes), `Makefile`, `.env` samples under `config/` when present.

## 3. Build, Run, and Tooling Commands
- `make run`, `make run-worker`, `make migrate`: Start the web app, workers, and schema migrations respectively.
- `make go-test`: Run unit tests under `internal/...`.
- `make run-clean`: Run lint, code generation, Swagger refresh, and boot sequence.
- `make docker-compose`: Reset local dependencies (Postgres, Kafka, Signoz, etc.).
- `make format`: gofmt + golangci-lint formatting sweep.
- `make check-tools`: Ensure required tooling is installed prior to development.

## 4. Coding Standards & Naming
- Keep Go code gofmt-clean (tabs, default formatting). Use `make format` before pushing.
- Package names stay lowercase (`repository`, `usecase`). Files use `snake_case.go`.
- Exported identifiers follow Go PascalCase while preserving initialisms (`HTTPServer`, `JSONEncoder`).
- Generated artifacts in `api/` are source-of-truth; regenerate instead of hand-editing.
- Likewise, `internal/mock` is produced by generators; modifying these files manually is a waste of time because changes are overwritten—extend generators instead.

## 5. Testing Guidance
- Prefer table-driven tests co-located with code using `_test.go` suffix and descriptive names like `TestUserRepository_FindByID`.
- Cover new use cases, repositories, and gateways; update fixtures when schemas evolve.
- Run `make go-test` before opening a PR to ensure unit coverage.

## 6. Environment & Configuration
- Use `make docker-compose` after checkout or schema changes to ensure Postgres/Kafka/Signoz stacks match expectations.
- Keep environment variables in sync with the `.env` samples and avoid committing secrets.
- Document any new external tooling in `README.md` and extend `make check-tools` when introducing additional CLIs or generators.

## 7. Commit & PR Expectations
- Commits follow the Conventional Commits format (`type(scope): subject`) with short, imperative subjects under 72 chars; group related changes together and reference issues in the body when relevant.
- Pull requests should summarize architectural impact, list verification steps (tests, migrations), and attach Swagger diffs/log snippets when behavior changes. Include UI screenshots for HTTP interface updates.

With the sections above, an agent can start from any symptom (HTTP request, worker job, failing test) and navigate directly to the relevant delivery adapter, use case, entity, repository, and migration to understand or modify behavior across the whole project.
