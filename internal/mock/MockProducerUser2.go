// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/Hidayathamir/golang-clean-architecture/internal/dto"
	"github.com/Hidayathamir/golang-clean-architecture/internal/infra/messaging"
	"sync"
)

// Ensure, that UserProducerMock does implement messaging.UserProducer.
// If this is not the case, regenerate this file with moq.
var _ messaging.UserProducer = &UserProducerMock{}

// UserProducerMock is a mock implementation of messaging.UserProducer.
//
//	func TestSomethingThatUsesUserProducer(t *testing.T) {
//
//		// make and configure a mocked messaging.UserProducer
//		mockedUserProducer := &UserProducerMock{
//			SendUserFollowedFunc: func(ctx context.Context, event *dto.UserFollowedEvent) error {
//				panic("mock out the SendUserFollowed method")
//			},
//		}
//
//		// use mockedUserProducer in code that requires messaging.UserProducer
//		// and then make assertions.
//
//	}
type UserProducerMock struct {
	// SendUserFollowedFunc mocks the SendUserFollowed method.
	SendUserFollowedFunc func(ctx context.Context, event *dto.UserFollowedEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// SendUserFollowed holds details about calls to the SendUserFollowed method.
		SendUserFollowed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *dto.UserFollowedEvent
		}
	}
	lockSendUserFollowed sync.RWMutex
}

// SendUserFollowed calls SendUserFollowedFunc.
func (mock *UserProducerMock) SendUserFollowed(ctx context.Context, event *dto.UserFollowedEvent) error {
	if mock.SendUserFollowedFunc == nil {
		panic("UserProducerMock.SendUserFollowedFunc: method is nil but UserProducer.SendUserFollowed was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *dto.UserFollowedEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockSendUserFollowed.Lock()
	mock.calls.SendUserFollowed = append(mock.calls.SendUserFollowed, callInfo)
	mock.lockSendUserFollowed.Unlock()
	return mock.SendUserFollowedFunc(ctx, event)
}

// SendUserFollowedCalls gets all the calls that were made to SendUserFollowed.
// Check the length with:
//
//	len(mockedUserProducer.SendUserFollowedCalls())
func (mock *UserProducerMock) SendUserFollowedCalls() []struct {
	Ctx   context.Context
	Event *dto.UserFollowedEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *dto.UserFollowedEvent
	}
	mock.lockSendUserFollowed.RLock()
	calls = mock.calls.SendUserFollowed
	mock.lockSendUserFollowed.RUnlock()
	return calls
}
