// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/Hidayathamir/golang-clean-architecture/internal/model"
	"github.com/Hidayathamir/golang-clean-architecture/internal/usecase/user"
	"sync"
)

// Ensure, that UserUsecaseMock does implement user.UserUsecase.
// If this is not the case, regenerate this file with moq.
var _ user.UserUsecase = &UserUsecaseMock{}

// UserUsecaseMock is a mock implementation of user.UserUsecase.
//
//	func TestSomethingThatUsesUserUsecase(t *testing.T) {
//
//		// make and configure a mocked user.UserUsecase
//		mockedUserUsecase := &UserUsecaseMock{
//			BatchUpdateUserFollowStatsFunc: func(ctx context.Context, req *model.BatchUpdateUserFollowStatsRequest) error {
//				panic("mock out the BatchUpdateUserFollowStats method")
//			},
//			CreateFunc: func(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Create method")
//			},
//			CurrentFunc: func(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Current method")
//			},
//			FollowFunc: func(ctx context.Context, req *model.FollowUserRequest) error {
//				panic("mock out the Follow method")
//			},
//			LoginFunc: func(ctx context.Context, req *model.LoginUserRequest) (*model.UserLoginResponse, error) {
//				panic("mock out the Login method")
//			},
//			NotifyUserBeingFollowedFunc: func(ctx context.Context, req *model.NotifyUserBeingFollowedRequest) error {
//				panic("mock out the NotifyUserBeingFollowed method")
//			},
//			UpdateFunc: func(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Update method")
//			},
//			VerifyFunc: func(ctx context.Context, req *model.VerifyUserRequest) (*model.UserAuth, error) {
//				panic("mock out the Verify method")
//			},
//		}
//
//		// use mockedUserUsecase in code that requires user.UserUsecase
//		// and then make assertions.
//
//	}
type UserUsecaseMock struct {
	// BatchUpdateUserFollowStatsFunc mocks the BatchUpdateUserFollowStats method.
	BatchUpdateUserFollowStatsFunc func(ctx context.Context, req *model.BatchUpdateUserFollowStatsRequest) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error)

	// CurrentFunc mocks the Current method.
	CurrentFunc func(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error)

	// FollowFunc mocks the Follow method.
	FollowFunc func(ctx context.Context, req *model.FollowUserRequest) error

	// LoginFunc mocks the Login method.
	LoginFunc func(ctx context.Context, req *model.LoginUserRequest) (*model.UserLoginResponse, error)

	// NotifyUserBeingFollowedFunc mocks the NotifyUserBeingFollowed method.
	NotifyUserBeingFollowedFunc func(ctx context.Context, req *model.NotifyUserBeingFollowedRequest) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(ctx context.Context, req *model.VerifyUserRequest) (*model.UserAuth, error)

	// calls tracks calls to the methods.
	calls struct {
		// BatchUpdateUserFollowStats holds details about calls to the BatchUpdateUserFollowStats method.
		BatchUpdateUserFollowStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.BatchUpdateUserFollowStatsRequest
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.RegisterUserRequest
		}
		// Current holds details about calls to the Current method.
		Current []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.GetUserRequest
		}
		// Follow holds details about calls to the Follow method.
		Follow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.FollowUserRequest
		}
		// Login holds details about calls to the Login method.
		Login []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.LoginUserRequest
		}
		// NotifyUserBeingFollowed holds details about calls to the NotifyUserBeingFollowed method.
		NotifyUserBeingFollowed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.NotifyUserBeingFollowedRequest
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.UpdateUserRequest
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.VerifyUserRequest
		}
	}
	lockBatchUpdateUserFollowStats sync.RWMutex
	lockCreate                     sync.RWMutex
	lockCurrent                    sync.RWMutex
	lockFollow                     sync.RWMutex
	lockLogin                      sync.RWMutex
	lockNotifyUserBeingFollowed    sync.RWMutex
	lockUpdate                     sync.RWMutex
	lockVerify                     sync.RWMutex
}

// BatchUpdateUserFollowStats calls BatchUpdateUserFollowStatsFunc.
func (mock *UserUsecaseMock) BatchUpdateUserFollowStats(ctx context.Context, req *model.BatchUpdateUserFollowStatsRequest) error {
	if mock.BatchUpdateUserFollowStatsFunc == nil {
		panic("UserUsecaseMock.BatchUpdateUserFollowStatsFunc: method is nil but UserUsecase.BatchUpdateUserFollowStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.BatchUpdateUserFollowStatsRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockBatchUpdateUserFollowStats.Lock()
	mock.calls.BatchUpdateUserFollowStats = append(mock.calls.BatchUpdateUserFollowStats, callInfo)
	mock.lockBatchUpdateUserFollowStats.Unlock()
	return mock.BatchUpdateUserFollowStatsFunc(ctx, req)
}

// BatchUpdateUserFollowStatsCalls gets all the calls that were made to BatchUpdateUserFollowStats.
// Check the length with:
//
//	len(mockedUserUsecase.BatchUpdateUserFollowStatsCalls())
func (mock *UserUsecaseMock) BatchUpdateUserFollowStatsCalls() []struct {
	Ctx context.Context
	Req *model.BatchUpdateUserFollowStatsRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.BatchUpdateUserFollowStatsRequest
	}
	mock.lockBatchUpdateUserFollowStats.RLock()
	calls = mock.calls.BatchUpdateUserFollowStats
	mock.lockBatchUpdateUserFollowStats.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *UserUsecaseMock) Create(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error) {
	if mock.CreateFunc == nil {
		panic("UserUsecaseMock.CreateFunc: method is nil but UserUsecase.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.RegisterUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, req)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUserUsecase.CreateCalls())
func (mock *UserUsecaseMock) CreateCalls() []struct {
	Ctx context.Context
	Req *model.RegisterUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.RegisterUserRequest
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Current calls CurrentFunc.
func (mock *UserUsecaseMock) Current(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error) {
	if mock.CurrentFunc == nil {
		panic("UserUsecaseMock.CurrentFunc: method is nil but UserUsecase.Current was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.GetUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCurrent.Lock()
	mock.calls.Current = append(mock.calls.Current, callInfo)
	mock.lockCurrent.Unlock()
	return mock.CurrentFunc(ctx, req)
}

// CurrentCalls gets all the calls that were made to Current.
// Check the length with:
//
//	len(mockedUserUsecase.CurrentCalls())
func (mock *UserUsecaseMock) CurrentCalls() []struct {
	Ctx context.Context
	Req *model.GetUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.GetUserRequest
	}
	mock.lockCurrent.RLock()
	calls = mock.calls.Current
	mock.lockCurrent.RUnlock()
	return calls
}

// Follow calls FollowFunc.
func (mock *UserUsecaseMock) Follow(ctx context.Context, req *model.FollowUserRequest) error {
	if mock.FollowFunc == nil {
		panic("UserUsecaseMock.FollowFunc: method is nil but UserUsecase.Follow was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.FollowUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockFollow.Lock()
	mock.calls.Follow = append(mock.calls.Follow, callInfo)
	mock.lockFollow.Unlock()
	return mock.FollowFunc(ctx, req)
}

// FollowCalls gets all the calls that were made to Follow.
// Check the length with:
//
//	len(mockedUserUsecase.FollowCalls())
func (mock *UserUsecaseMock) FollowCalls() []struct {
	Ctx context.Context
	Req *model.FollowUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.FollowUserRequest
	}
	mock.lockFollow.RLock()
	calls = mock.calls.Follow
	mock.lockFollow.RUnlock()
	return calls
}

// Login calls LoginFunc.
func (mock *UserUsecaseMock) Login(ctx context.Context, req *model.LoginUserRequest) (*model.UserLoginResponse, error) {
	if mock.LoginFunc == nil {
		panic("UserUsecaseMock.LoginFunc: method is nil but UserUsecase.Login was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.LoginUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	mock.lockLogin.Unlock()
	return mock.LoginFunc(ctx, req)
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//
//	len(mockedUserUsecase.LoginCalls())
func (mock *UserUsecaseMock) LoginCalls() []struct {
	Ctx context.Context
	Req *model.LoginUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.LoginUserRequest
	}
	mock.lockLogin.RLock()
	calls = mock.calls.Login
	mock.lockLogin.RUnlock()
	return calls
}

// NotifyUserBeingFollowed calls NotifyUserBeingFollowedFunc.
func (mock *UserUsecaseMock) NotifyUserBeingFollowed(ctx context.Context, req *model.NotifyUserBeingFollowedRequest) error {
	if mock.NotifyUserBeingFollowedFunc == nil {
		panic("UserUsecaseMock.NotifyUserBeingFollowedFunc: method is nil but UserUsecase.NotifyUserBeingFollowed was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.NotifyUserBeingFollowedRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockNotifyUserBeingFollowed.Lock()
	mock.calls.NotifyUserBeingFollowed = append(mock.calls.NotifyUserBeingFollowed, callInfo)
	mock.lockNotifyUserBeingFollowed.Unlock()
	return mock.NotifyUserBeingFollowedFunc(ctx, req)
}

// NotifyUserBeingFollowedCalls gets all the calls that were made to NotifyUserBeingFollowed.
// Check the length with:
//
//	len(mockedUserUsecase.NotifyUserBeingFollowedCalls())
func (mock *UserUsecaseMock) NotifyUserBeingFollowedCalls() []struct {
	Ctx context.Context
	Req *model.NotifyUserBeingFollowedRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.NotifyUserBeingFollowedRequest
	}
	mock.lockNotifyUserBeingFollowed.RLock()
	calls = mock.calls.NotifyUserBeingFollowed
	mock.lockNotifyUserBeingFollowed.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *UserUsecaseMock) Update(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error) {
	if mock.UpdateFunc == nil {
		panic("UserUsecaseMock.UpdateFunc: method is nil but UserUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.UpdateUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, req)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedUserUsecase.UpdateCalls())
func (mock *UserUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Req *model.UpdateUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.UpdateUserRequest
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *UserUsecaseMock) Verify(ctx context.Context, req *model.VerifyUserRequest) (*model.UserAuth, error) {
	if mock.VerifyFunc == nil {
		panic("UserUsecaseMock.VerifyFunc: method is nil but UserUsecase.Verify was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.VerifyUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	return mock.VerifyFunc(ctx, req)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(mockedUserUsecase.VerifyCalls())
func (mock *UserUsecaseMock) VerifyCalls() []struct {
	Ctx context.Context
	Req *model.VerifyUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.VerifyUserRequest
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}
