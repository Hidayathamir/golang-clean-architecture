// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/Hidayathamir/golang-clean-architecture/internal/model"
	"github.com/Hidayathamir/golang-clean-architecture/internal/usecase/user"
	"sync"
)

// Ensure, that UserUsecaseMock does implement user.UserUsecase.
// If this is not the case, regenerate this file with moq.
var _ user.UserUsecase = &UserUsecaseMock{}

// UserUsecaseMock is a mock implementation of user.UserUsecase.
//
//	func TestSomethingThatUsesUserUsecase(t *testing.T) {
//
//		// make and configure a mocked user.UserUsecase
//		mockedUserUsecase := &UserUsecaseMock{
//			CreateFunc: func(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Create method")
//			},
//			CurrentFunc: func(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Current method")
//			},
//			LoginFunc: func(ctx context.Context, req *model.LoginUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Login method")
//			},
//			LogoutFunc: func(ctx context.Context, req *model.LogoutUserRequest) (bool, error) {
//				panic("mock out the Logout method")
//			},
//			UpdateFunc: func(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error) {
//				panic("mock out the Update method")
//			},
//			VerifyFunc: func(ctx context.Context, req *model.VerifyUserRequest) (*model.Auth, error) {
//				panic("mock out the Verify method")
//			},
//		}
//
//		// use mockedUserUsecase in code that requires user.UserUsecase
//		// and then make assertions.
//
//	}
type UserUsecaseMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error)

	// CurrentFunc mocks the Current method.
	CurrentFunc func(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error)

	// LoginFunc mocks the Login method.
	LoginFunc func(ctx context.Context, req *model.LoginUserRequest) (*model.UserResponse, error)

	// LogoutFunc mocks the Logout method.
	LogoutFunc func(ctx context.Context, req *model.LogoutUserRequest) (bool, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error)

	// VerifyFunc mocks the Verify method.
	VerifyFunc func(ctx context.Context, req *model.VerifyUserRequest) (*model.Auth, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.RegisterUserRequest
		}
		// Current holds details about calls to the Current method.
		Current []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.GetUserRequest
		}
		// Login holds details about calls to the Login method.
		Login []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.LoginUserRequest
		}
		// Logout holds details about calls to the Logout method.
		Logout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.LogoutUserRequest
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.UpdateUserRequest
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *model.VerifyUserRequest
		}
	}
	lockCreate  sync.RWMutex
	lockCurrent sync.RWMutex
	lockLogin   sync.RWMutex
	lockLogout  sync.RWMutex
	lockUpdate  sync.RWMutex
	lockVerify  sync.RWMutex
}

// Create calls CreateFunc.
func (mock *UserUsecaseMock) Create(ctx context.Context, req *model.RegisterUserRequest) (*model.UserResponse, error) {
	if mock.CreateFunc == nil {
		panic("UserUsecaseMock.CreateFunc: method is nil but UserUsecase.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.RegisterUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, req)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedUserUsecase.CreateCalls())
func (mock *UserUsecaseMock) CreateCalls() []struct {
	Ctx context.Context
	Req *model.RegisterUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.RegisterUserRequest
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Current calls CurrentFunc.
func (mock *UserUsecaseMock) Current(ctx context.Context, req *model.GetUserRequest) (*model.UserResponse, error) {
	if mock.CurrentFunc == nil {
		panic("UserUsecaseMock.CurrentFunc: method is nil but UserUsecase.Current was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.GetUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockCurrent.Lock()
	mock.calls.Current = append(mock.calls.Current, callInfo)
	mock.lockCurrent.Unlock()
	return mock.CurrentFunc(ctx, req)
}

// CurrentCalls gets all the calls that were made to Current.
// Check the length with:
//
//	len(mockedUserUsecase.CurrentCalls())
func (mock *UserUsecaseMock) CurrentCalls() []struct {
	Ctx context.Context
	Req *model.GetUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.GetUserRequest
	}
	mock.lockCurrent.RLock()
	calls = mock.calls.Current
	mock.lockCurrent.RUnlock()
	return calls
}

// Login calls LoginFunc.
func (mock *UserUsecaseMock) Login(ctx context.Context, req *model.LoginUserRequest) (*model.UserResponse, error) {
	if mock.LoginFunc == nil {
		panic("UserUsecaseMock.LoginFunc: method is nil but UserUsecase.Login was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.LoginUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	mock.lockLogin.Unlock()
	return mock.LoginFunc(ctx, req)
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//
//	len(mockedUserUsecase.LoginCalls())
func (mock *UserUsecaseMock) LoginCalls() []struct {
	Ctx context.Context
	Req *model.LoginUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.LoginUserRequest
	}
	mock.lockLogin.RLock()
	calls = mock.calls.Login
	mock.lockLogin.RUnlock()
	return calls
}

// Logout calls LogoutFunc.
func (mock *UserUsecaseMock) Logout(ctx context.Context, req *model.LogoutUserRequest) (bool, error) {
	if mock.LogoutFunc == nil {
		panic("UserUsecaseMock.LogoutFunc: method is nil but UserUsecase.Logout was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.LogoutUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLogout.Lock()
	mock.calls.Logout = append(mock.calls.Logout, callInfo)
	mock.lockLogout.Unlock()
	return mock.LogoutFunc(ctx, req)
}

// LogoutCalls gets all the calls that were made to Logout.
// Check the length with:
//
//	len(mockedUserUsecase.LogoutCalls())
func (mock *UserUsecaseMock) LogoutCalls() []struct {
	Ctx context.Context
	Req *model.LogoutUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.LogoutUserRequest
	}
	mock.lockLogout.RLock()
	calls = mock.calls.Logout
	mock.lockLogout.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *UserUsecaseMock) Update(ctx context.Context, req *model.UpdateUserRequest) (*model.UserResponse, error) {
	if mock.UpdateFunc == nil {
		panic("UserUsecaseMock.UpdateFunc: method is nil but UserUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.UpdateUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, req)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedUserUsecase.UpdateCalls())
func (mock *UserUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Req *model.UpdateUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.UpdateUserRequest
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (mock *UserUsecaseMock) Verify(ctx context.Context, req *model.VerifyUserRequest) (*model.Auth, error) {
	if mock.VerifyFunc == nil {
		panic("UserUsecaseMock.VerifyFunc: method is nil but UserUsecase.Verify was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *model.VerifyUserRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockVerify.Lock()
	mock.calls.Verify = append(mock.calls.Verify, callInfo)
	mock.lockVerify.Unlock()
	return mock.VerifyFunc(ctx, req)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(mockedUserUsecase.VerifyCalls())
func (mock *UserUsecaseMock) VerifyCalls() []struct {
	Ctx context.Context
	Req *model.VerifyUserRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *model.VerifyUserRequest
	}
	mock.lockVerify.RLock()
	calls = mock.calls.Verify
	mock.lockVerify.RUnlock()
	return calls
}
